/*
 *  Copyright (c) 2017 Marco Iorio (giorio94 at gmail dot com)
 *  This file is part of Share Your Files (SYF).
 *
 *  SYF is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  SYF is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with SYF.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "threadpool.hpp"

#include <Logger.h>

#include <QThread>

// Static variables definition
QScopedPointer<QThread> ThreadPool::m_syfdThread;
QScopedPointer<QThread> ThreadPool::m_syfpThread;
QScopedPointer<QThread> ThreadPool::m_syfftRecvThread;
QScopedPointer<QThread> ThreadPool::m_syfftSenderThread;

///
/// \brief Creates and starts a thread.
/// \param pointer the QScopedPointer where the thread pointer is to be stored.
/// \param threadName the name of the thread (for identification).
///
static void startThread(QScopedPointer<QThread> &pointer,
                        const QString &threadName)
{
    pointer.reset(new QThread());
    pointer->setObjectName(threadName);
    pointer->start();
    LOG_INFO() << qUtf8Printable(threadName)
               << "Thread ID:" << static_cast<void *>(pointer.data());
}

///
/// \brief Stops and destroys thread.
/// \param pointer the QScopedPointer where the thread pointer is stored.
///
static void stopThread(QScopedPointer<QThread> &pointer)
{
    // If the thread is running, stop it and wait for termination
    if (!pointer.isNull()) {
        pointer->quit();
        pointer->wait();

        LOG_INFO() << qUtf8Printable(pointer->objectName())
                   << "Thread terminated";
    }
    // Destroy the instance
    pointer.reset();
}

///
/// The instances are generated by creating the thread objects and starting the
/// associated flows of execution (they will begin executing the event loop).
///
void ThreadPool::createInstance()
{
    LOG_INFO() << "Thread pool initialization...";

    // Create and start the threads
    startThread(m_syfdThread, "SYFD");
    startThread(m_syfpThread, "SYFP");
    startThread(m_syfftRecvThread, "SYFFT Receiver");
    startThread(m_syfftSenderThread, "SYFFT Sender");

    LOG_INFO() << "Thread pool initialization completed";
}

///
/// The instances are destroyed by politely stopping the threads, waiting for
/// their termination and then deleting the objects representing them.
///
void ThreadPool::destroyInstance()
{
    LOG_INFO() << "Thread pool destruction...";

    // Stop and destroy the threads
    stopThread(m_syfftSenderThread);
    stopThread(m_syfftRecvThread);
    stopThread(m_syfpThread);
    stopThread(m_syfdThread);

    LOG_INFO() << "Thread pool destruction completed";
}
